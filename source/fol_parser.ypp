%language "c++"
%require "3.2"
%define api.token.constructor
%define api.value.type variant

%code requires {
    class FOLDriver;
    class Term;
    class Atom;
    class Formula;
    #include <memory>
    #include "fraction.hpp"
}

%param { FOLDriver &driver }

%code {
    #include "fol_driver.hpp"
}

%token <int> INT_T
%token <std::string> VAR_T
%token LEQ_T GEQ_T NEQ_T TRUE_T FALSE_T IMPL_T EQUI_T

%left '!' '?' '.'
%right EQUI_T
%right IMPL_T
%left '|'
%left '&'
%left '~'
%left '=' '<' '>' LEQ_T GEQ_T NEQ_T
%left '+' '-'
%left '*' '/'

%nterm <Fraction> fraction
%nterm <std::shared_ptr<Term>> term
%nterm <std::shared_ptr<Atom>> atom
%nterm <std::shared_ptr<Formula>> formula

%start complete_formula

%%

complete_formula:
    formula {
        driver.m_ast = $1;
    }
;

formula:
    '~' formula {
        $$ = f_ptr<Negation>($2);
    }
|   formula '&' formula {
        $$ = f_ptr<Conjuction>($1, $3);
    }
|   formula '|' formula {
        $$ = f_ptr<Disjunction>($1, $3);
    }
|   formula IMPL_T formula {
        $$ = f_ptr<Implication>($1, $3);
    }
|   formula EQUI_T formula {
        $$ = f_ptr<Equivalence>($1, $3);
    }
|   '!' VAR_T '.' formula {
        $$ = f_ptr<UniversalQuantification>($2, $4);
    }
|   '?' VAR_T '.' formula {
        $$ = f_ptr<ExistentialQuantification>($2, $4);
    }
|   '(' formula ')' {
        $$ = $2;
    }
|   atom {
        $$ = f_ptr<AtomWrapper>($1);
    }
|   TRUE_T {
        $$ = f_ptr<True>();
    }
|   FALSE_T {
        $$ = f_ptr<False>();
    }
;

atom:
    term '=' term {
        $$ = a_ptr<EqualTo>($1, $3);
    }
|   term '<' term {
        $$ = a_ptr<LessThan>($1, $3);
    }
|   term '>' term {
        $$ = a_ptr<GreaterThan>($1, $3);
    }
|   term LEQ_T term {
        $$ = a_ptr<LessOrEqualTo>($1, $3);
    }
|   term GEQ_T term {
        $$ = a_ptr<GreaterOrEqualTo>($1, $3);
    }
|   term NEQ_T term {
        $$ = a_ptr<NotEqualTo>($1, $3);
    }
;

term:
    term '+' term {
        $$ = t_ptr<Addition>($1, $3);
    }
|   term '-' term {
        $$ = t_ptr<Subtraction>($1, $3);
    }
|   fraction '*' VAR_T {
        $$ = t_ptr<Variable>($1, $3);
    }
|   VAR_T {
        $$ = t_ptr<Variable>(Fraction(1, 1), $1);
    }
|   fraction {
        $$ = t_ptr<RationalNumber>($1);
    }
;

fraction:
    INT_T {
        $$ = Fraction($1);
    }
|   INT_T '/' INT_T {
        $$ = Fraction($1, $3);
    }
;

%%

void yy::parser::error(const std::string &message)
{

}
